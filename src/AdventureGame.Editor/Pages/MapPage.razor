@page "/gamepack/map"
@using System.Text.Json
@inject IJSRuntime JS
@inject AdventureGame.Editor.Services.CurrentGameService CurrentGameService
@inject DialogService DialogService

<RadzenText TextStyle="TextStyle.H3">Map</RadzenText>

<div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
    <button class="rz-button rz-button-primary" @onclick="ZoomIn" title="Zoom in">Zoom In</button>
    <button class="rz-button" @onclick="ZoomOut" title="Zoom out">Zoom Out</button>
    <button class="rz-button" @onclick="ResetZoom" title="Reset zoom">Reset</button>
    <div style="margin-left:8px; color:#333;">Zoom: @Math.Round(Scale * 100) %</div>

    <div style="margin-left:16px; display:flex; gap:8px; align-items:center;">
        <label style="color:#333; font-size:0.9rem;">Level:</label>
        <Radzen.Blazor.RadzenNumeric @bind-Value="Level" TValue="int" Style="width:8ch;"
                                     Change="@(async _ => await OnLevelChanged())" />
    </div>

    <div style="margin-left:auto; color:#666; font-size:0.9rem;">Tip: Hold Ctrl + Mouse Wheel to zoom</div>
</div>
<RadzenRow>
    <RadzenColumn>


<div class="map-viewport" @ref="_viewportRef"
     style="width:40vw; height:75vh; border:1px solid #ddd; overflow:auto; background:#fafafa;"
     @onwheel="OnWheel">
    @if (LogicalWidth > 0 && LogicalHeight > 0)
    {
        <div style="width:@(LogicalWidth* Scale)px; height:@(LogicalHeight* Scale)px; position:relative;">
            <div style="position:absolute; top:0; left:0; transform:scale(@Scale); transform-origin:0 0;">
                <svg width="@LogicalWidth" height="@LogicalHeight"
                     viewBox="0 0 @Math.Round(LogicalWidth) @Math.Round(LogicalHeight)"
                     xmlns="http://www.w3.org/2000/svg"
                     @onpointerup="EndSceneInteraction">

                    @* GRID PATTERN *@
                    <defs>
                        <pattern id="gridPattern" width="@GridCellWidth" height="@GridCellHeight" patternUnits="userSpaceOnUse">
                            <rect width="@GridCellWidth" height="@GridCellHeight" fill="transparent"
                                  stroke="#666" stroke-width="1" stroke-dasharray="1,6" />
                        </pattern>
                    </defs>
                    <rect x="0" y="0" width="@LogicalWidth" height="@LogicalHeight" fill="url(#gridPattern)" />

                    @* SCENES *@
                    @if (CurrentGameService?.CurrentPack is not null)
                    {
                        @foreach (var s in VisibleScenesOnLevel)
                        {
                            var pos = s.Location.TryGetPosition(out var p) ? p : default;
                            var cols = Math.Max(1, s.ExtentInCells.Columns);
                            var rows = Math.Max(1, s.ExtentInCells.Rows);

                            var leftCol = pos.X - MinX;
                            var topRow = MaxY - (pos.Y + rows - 1);

                            var margin = 15.0; // increased padding so coord labels sit outside scene
                            var rectX = leftCol * GridCellWidth + margin;
                            var rectY = topRow * GridCellHeight + margin;
                            var rectW = Math.Max(4, cols * GridCellWidth - margin * 2);
                            var rectH = Math.Max(8, rows * GridCellHeight - margin * 2);

                            var offset = _sceneOffsets.TryGetValue(s.Id.ToString(), out var off) ? off : (0d, 0d);

                            <g class="scene"
                               transform="translate(@offset.Item1,@offset.Item2)"
                               @onpointerdown="@(e => StartSceneDrag(e, s))"
                               @onpointermove="@(e => DragScene(e))"
                               @onpointerup="@(s => EndSceneInteraction())"
                               style="touch-action:none; cursor:move;">
                                <rect x="@rectX" y="@rectY" width="@rectW" height="@rectH"
                                        fill="@(s == currentScene ? "#fdf3e0" : "#f5e6d3")"
                                        stroke="@(s == currentScene ? "#d97706" : "#b89f85")"
                                        stroke-width="@(s == currentScene ? 3 : 1)"
                                        rx="6" ry="6" />

                                @* Extent dimensions shown near the top-left inside the scene *@
                                <svg:text class="scene-dim" x="@(rectX + 8)" y="@(rectY + 14)" font-size="10" fill="#3b2f25" text-anchor="start">@($"{cols}×{rows}")</svg:text>

                                <svg:text class="scene-name" x="@(rectX + rectW / 2)" y="@(rectY + rectH - 6)"
                                          font-size="12" fill="#3b2f25" text-anchor="middle">@s.Name</svg:text>

                                
                            </g>
                        }

                        @* EXIT CONNECTIONS AND MARKERS *@
                        {
                            var pack = CurrentGameService.CurrentPack!;
                            var ExitPositions = new Dictionary<ElementId, (double X, double Y)>();

                            foreach (var s in VisibleScenesOnLevel)
                            {
                                var spos = s.Location.TryGetPosition(out var sp) ? sp : default;
                                var scols = Math.Max(1, s.ExtentInCells.Columns);
                                var srows = Math.Max(1, s.ExtentInCells.Rows);
                                var sLeftCol = spos.X - MinX;
                                var sTopRow = MaxY - (spos.Y + srows - 1);
                                var smargin = 15.0;
                                var sRectX = sLeftCol * GridCellWidth + smargin;
                                var sRectY = sTopRow * GridCellHeight + smargin;
                                var sRectW = Math.Max(4, scols * GridCellWidth - smargin * 2);
                                var sRectH = Math.Max(8, srows * GridCellHeight - smargin * 2);

                                var soff = _sceneOffsets.TryGetValue(s.Id.ToString(), out var off2) ? off2 : (0d, 0d);

                                foreach (var ex in pack.Elements.OfType<Exit>().Where(e => e.Location?.ParentId == s.Id))
                                {
                                    double cx = sRectX + sRectW / 2 + soff.Item1;
                                    double cy = sRectY + sRectH / 2 + soff.Item2;

                                    if (ex.Direction is Direction d)
                                    {
                                        switch (d)
                                        {
                                            case Direction.North:
                                                cx = sRectX + sRectW / 2 + soff.Item1; cy = sRectY + soff.Item2; break;
                                            case Direction.South:
                                                cx = sRectX + sRectW / 2 + soff.Item1; cy = sRectY + sRectH + soff.Item2; break;
                                            case Direction.East:
                                                cx = sRectX + sRectW + soff.Item1; cy = sRectY + sRectH / 2 + soff.Item2; break;
                                            case Direction.West:
                                                cx = sRectX + soff.Item1; cy = sRectY + sRectH / 2 + soff.Item2; break;
                                            case Direction.NorthEast:
                                                cx = sRectX + sRectW + soff.Item1; cy = sRectY + soff.Item2; break;
                                            case Direction.NorthWest:
                                                cx = sRectX + soff.Item1; cy = sRectY + soff.Item2; break;
                                            case Direction.SouthEast:
                                                cx = sRectX + sRectW + soff.Item1; cy = sRectY + sRectH + soff.Item2; break;
                                            case Direction.SouthWest:
                                                cx = sRectX + soff.Item1; cy = sRectY + sRectH + soff.Item2; break;
                                            case Direction.Up:
                                                cx = sRectX + sRectW / 2 + soff.Item1; cy = sRectY - 6 + soff.Item2; break;
                                            case Direction.Down:
                                                cx = sRectX + sRectW / 2 + soff.Item1; cy = sRectY + sRectH + 6 + soff.Item2; break;
                                        }
                                    }
                                    else
                                    {
                                        // custom exit: if exit has a world position, place accordingly, otherwise default near right edge of scene
                                        if (ex.Location.TryGetPosition(out var ep))
                                        {
                                            var exLeft = ep.X - MinX;
                                            var exTop = MaxY - ep.Y;
                                            cx = exLeft * GridCellWidth + GridCellWidth / 2;
                                            cy = exTop * GridCellHeight + GridCellHeight / 2;
                                        }
                                        else
                                        {
                                            cx = sRectX + sRectW - 8 + soff.Item1;
                                            cy = sRectY + sRectH / 2 + soff.Item2;
                                        }
                                    }

                                    ExitPositions[ex.Id] = (cx, cy);
                                }
                            }

                            // draw lines between connected exits (if both endpoints are visible)

                            <g stroke="#6b7280" stroke-width="2" fill="none">
    @foreach (var kv in ExitPositions)
    {
        var ex = CurrentGameService.CurrentPack!.Elements.OfType<Exit>().FirstOrDefault(x => x.Id == kv.Key);
        if (ex?.TargetExitId is ElementId tid && ExitPositions.TryGetValue(tid, out var to))
        {
            <line x1="@kv.Value.X" y1="@kv.Value.Y" x2="@to.X" y2="@to.Y" stroke="#6b7280" stroke-width="2" stroke-linecap="round" style="cursor:pointer;" @onclick="() => OnExitLineClick(kv.Key, tid)" />
        }
    }
</g>
<g>
    @foreach (var kv in ExitPositions)
    {
        var isSelected = IsSelectedExit(kv.Key);
        <circle cx="@kv.Value.X" cy="@kv.Value.Y" r="@(isSelected ? 5 : 3)" fill="@(isSelected ? "#10b981" : "#f97316")" stroke="#b45309" stroke-width="@(isSelected ? 2 : 1)" style="cursor:pointer;" @onclick="() => OnExitMarkerClick(kv.Key)" />
    }
</g>
                        }
                    }

                    @* COORD LABELS *@
                    @for (int r = 0; r < RowsTotal; r++)
                    {
                        @for (int c = 0; c < ColsTotal; c++)
                        {
                            var labelX = c * GridCellWidth + 4;
                            var labelY = r * GridCellHeight + 4;
                            var coordX = c + MinX;
                            var coordY = MaxY - r;
                            <svg:text class="coord-label" x="@labelX" y="@labelY" font-size="8" fill="#666"
                                      text-anchor="start" dominant-baseline="hanging"
                                      style="pointer-events:none;">@($"({coordX},{coordY})")</svg:text>
                        }
                    }
                </svg>
            </div>
        </div>
    }
    else
    {
        <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#999;">
            Measuring map size...
        </div>
    }
</div>
    </RadzenColumn>
    <RadzenColumn>
        <RadzenPanel Style="width:100%;">

            <div style="padding:12px;">
                @if (_selectedExitAId is not null)
                {
                    <RadzenText TextStyle="TextStyle.H6">Current Exits</RadzenText>


                    <ExitPairDetails ExitA="@_selectedExitA" ExitB="@_selectedExitB" OnClose="@(() => ClearExitSelection())" />
                }
                else
                {
                    <div style="display:flex; align-items:center; gap:8px; padding:8px 12px;">
                        <RadzenText TextStyle="TextStyle.H6">Current Scene</RadzenText>
                        <div style="margin-left:auto; display:flex; gap:6px;">
                            <RadzenButton Icon="edit" Text="Edit" Size="ButtonSize.Small" ButtonStyle="ButtonStyle.Primary" Click="@(() => EditCurrentScene())" Disabled="@(currentScene == null)" />
                            <RadzenButton Icon="delete" Text="Delete" Size="ButtonSize.Small" ButtonStyle="ButtonStyle.Danger" Click="@(async () => await DeleteCurrentScene())" Disabled="@(currentScene == null)" />
                        </div>
                    </div>

                    <CurrentSceneDetails CurrentScene="currentScene" />
                }
            </div>
        </RadzenPanel>

    </RadzenColumn>
</RadzenRow>
@code {
    int GridCellWidth = 100;
    int GridCellHeight = 100;
    double LogicalWidth, LogicalHeight;
    int ColsTotal, RowsTotal;
    int MinX, MaxX, MinY, MaxY;
    const double DragThreshold = 5.0; // pixels
    ElementReference _viewportRef;

    private Scene? currentScene { get; set; } 

    // Exit selection state
    private ElementId? _selectedExitAId;
    private ElementId? _selectedExitBId;
    private Exit? _selectedExitA;
    private Exit? _selectedExitB;

    double Scale = 1.0;
    const double ZoomFactor = 1.25;
    const double MinScale = 0.1;
    const double MaxScale = 4.0;

    int Level = 0;
    List<Scene> VisibleScenesOnLevel = new();
    bool _initialized = false;

    // Drag state
    Scene? _draggingScene;
    double _dragStartX, _dragStartY;
    int _startGridX, _startGridY;
    bool _sceneDragging = false;
    double _tempDx, _tempDy;
    Dictionary<string, (double, double)> _sceneOffsets = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await RegisterMapHelpersAsync();
            //try { await EnableMapDragAsync(_viewportRef); } catch { }
            CurrentGameService.OnChange += OnPackChanged;
            _initialized = true;
            RefreshVisibleScenes();
            ComputeGridLines();
            StateHasChanged();
        }
    }

    void ComputeGridLines()
    {
        var pack = CurrentGameService.CurrentPack;
        int minX = int.MaxValue, maxX = int.MinValue;
        int minY = int.MaxValue, maxY = int.MinValue;

        if (pack != null)
        {
            foreach (var s in pack.Elements.OfType<Scene>())
            {
                if (s.Location.TryGetPosition(out var p))
                {
                    var zStart = p.Z;
                    var zLevels = Math.Max(1, s.ExtentInCells.Levels);
                    var zEnd = p.Z + zLevels - 1;

                    if (Level >= zStart && Level <= zEnd)
                    {
                        int x1 = p.X;
                        int x2 = p.X + s.ExtentInCells.Columns - 1;
                        int y1 = p.Y;
                        int y2 = p.Y + s.ExtentInCells.Rows - 1;

                        minX = Math.Min(minX, x1);
                        maxX = Math.Max(maxX, x2);
                        minY = Math.Min(minY, y1);
                        maxY = Math.Max(maxY, y2);
                    }
                }
            }
        }

        if (minX == int.MaxValue)
        {
            minX = -1; maxX = 1; minY = -1; maxY = 1;
        }

        minX--; maxX++; minY--; maxY++;

        MinX = minX; MaxX = maxX; MinY = minY; MaxY = maxY;

        ColsTotal = (MaxX - MinX + 1);
        RowsTotal = (MaxY - MinY + 1);
        LogicalWidth = ColsTotal * GridCellWidth;
        LogicalHeight = RowsTotal * GridCellHeight;
    }

    void ZoomIn() => Scale = Math.Clamp(Scale * ZoomFactor, MinScale, MaxScale);
    void ZoomOut() => Scale = Math.Clamp(Scale / ZoomFactor, MinScale, MaxScale);
    void ResetZoom() => Scale = 1.0;

    async Task OnWheel(Microsoft.AspNetCore.Components.Web.WheelEventArgs e)
    {
        if (e.CtrlKey)
        {
            if (e.DeltaY < 0) ZoomIn(); else ZoomOut();
            await InvokeAsync(StateHasChanged);
        }
    }

    void RefreshVisibleScenes()
    {
        VisibleScenesOnLevel.Clear();
        var pack = CurrentGameService.CurrentPack;
        if (pack == null) return;

        foreach (var s in pack.Elements.OfType<Scene>())
        {
            if (s.Location.TryGetPosition(out var p))
            {
                var zStart = p.Z;
                var zLevels = Math.Max(1, s.ExtentInCells.Levels);
                var zEnd = p.Z + zLevels - 1;

                if (Level >= zStart && Level <= zEnd)
                    VisibleScenesOnLevel.Add(s);
            }
        }

        // Set default currentScene to scene at (0,0) on this level
        if (currentScene == null)
        {
            currentScene = VisibleScenesOnLevel.FirstOrDefault(s => s.Location.TryGetPosition(out var p) && p.X == 0 && p.Y == 0 && (Level >= p.Z && Level <= p.Z + Math.Max(1, s.ExtentInCells.Levels) - 1));
        }
    }

    void OnPackChanged()
    {
        RefreshVisibleScenes();
        ComputeGridLines();
        InvokeAsync(StateHasChanged);
    }

    void SelectScene(Scene s)
    {
        // If an exit was selected, clear it when selecting a scene.
        ClearExitSelection();
        currentScene = s;
        StateHasChanged();
    }

    void StartSceneDrag(Microsoft.AspNetCore.Components.Web.PointerEventArgs e, Scene scene)
    {
        _draggingScene = scene;
        _sceneDragging = true;
        _dragStartX = e.ClientX;
        _dragStartY = e.ClientY;

        if (scene.Location.TryGetPosition(out var p))
        {
            _startGridX = p.X;
            _startGridY = p.Y;
        }
        _tempDx = _tempDy = 0;
    }

    void DragScene(Microsoft.AspNetCore.Components.Web.PointerEventArgs e)
    {
        if (!_sceneDragging || _draggingScene == null) return;

        _tempDx = (e.ClientX - _dragStartX) / Scale;
        _tempDy = (e.ClientY - _dragStartY) / Scale;

        _sceneOffsets[_draggingScene.Id.ToString()] = (_tempDx, _tempDy);
        InvokeAsync(StateHasChanged);
    }

    void EndSceneInteraction()
    {
        if (!_sceneDragging || _draggingScene == null)
            return;

        // Calculate total movement distance
        var distance = Math.Sqrt(_tempDx * _tempDx + _tempDy * _tempDy);

        if (distance < DragThreshold)
        {
            // Treat as click — select scene instead of drag
            SelectScene(_draggingScene);
        }
        else
        {
            // Commit drag to grid
            int deltaCols = (int)Math.Round(_tempDx / GridCellWidth);
            int deltaRows = (int)Math.Round(_tempDy / GridCellHeight);

            if (_draggingScene.Location.TryGetPosition(out var pos))
            {
                pos = pos with { X = _startGridX + deltaCols, Y = _startGridY - deltaRows };
                _draggingScene.Location = Location.World(pos);
            }

            CurrentGameService.MarkDirty();
            ComputeGridLines();
        }

        _sceneOffsets.Remove(_draggingScene.Id.ToString());
        _sceneDragging = false;
        _draggingScene = null;

        InvokeAsync(StateHasChanged);
    }

    // Exit selection handling
    void OnExitMarkerClick(ElementId id)
    {
        var pack = CurrentGameService.CurrentPack;
        if (pack is null) return;
        var ex = pack.Elements.OfType<Exit>().FirstOrDefault(x => x.Id == id);
        if (ex is null) return;

        // If this exit links to a target, select the pair (toggle off if already selected)
        if (ex.TargetExitId is ElementId tid)
        {
            var target = pack.Elements.OfType<Exit>().FirstOrDefault(x => x.Id == tid);
            if (target != null)
            {
                // If the pair is already selected (in either order), toggle off
                if ((_selectedExitAId == ex.Id && _selectedExitBId == target.Id) || (_selectedExitAId == target.Id && _selectedExitBId == ex.Id))
                {
                    ClearExitSelection();
                    return;
                }

                // Select both endpoints
                _selectedExitAId = ex.Id; _selectedExitA = ex;
                _selectedExitBId = target.Id; _selectedExitB = target;

                // Clear current scene selection
                currentScene = null;
                StateHasChanged();
                return;
            }
        }

        // Fallback: single-exit selection (existing behavior)
        // Start new selection if none or if two already selected
        if (_selectedExitAId is null || (_selectedExitAId is not null && _selectedExitBId is not null))
        {
            _selectedExitAId = ex.Id;
            _selectedExitA = ex;
            _selectedExitBId = null;
            _selectedExitB = null;
        }
        else if (_selectedExitAId == ex.Id)
        {
            // toggle off
            _selectedExitAId = null; _selectedExitA = null; _selectedExitBId = null; _selectedExitB = null;
        }
        else
        {
            _selectedExitBId = ex.Id;
            _selectedExitB = ex;
        }

        // Clear current scene selection
        currentScene = null;
        StateHasChanged();
    }

    void OnExitLineClick(ElementId aId, ElementId bId)
    {
        var pack = CurrentGameService.CurrentPack;
        if (pack is null) return;
        var a = pack.Elements.OfType<Exit>().FirstOrDefault(e => e.Id == aId);
        var b = pack.Elements.OfType<Exit>().FirstOrDefault(e => e.Id == bId);
        if (a is null || b is null) return;

        // If the pair is already selected (in either order), toggle off
        if ((_selectedExitAId == aId && _selectedExitBId == bId) || (_selectedExitAId == bId && _selectedExitBId == aId))
        {
            ClearExitSelection();
            return;
        }

        // Select both endpoints
        _selectedExitAId = aId; _selectedExitA = a;
        _selectedExitBId = bId; _selectedExitB = b;

        // Clear current scene selection
        currentScene = null;
        StateHasChanged();
    }

    bool IsSelectedExit(ElementId id) => (id == _selectedExitAId) || (id == _selectedExitBId);

    void ClearExitSelection()
    {
        _selectedExitAId = null; _selectedExitBId = null; _selectedExitA = null; _selectedExitB = null;
        StateHasChanged();
    }


    public async ValueTask DisposeAsync()
    {
        try { await DisableMapDragAsync(_viewportRef); } catch { }
        try { await DisposeMapModuleAsync(); } catch { }
        if (_initialized)
        {
            CurrentGameService.OnChange -= OnPackChanged;
            _initialized = false;
        }
    }

    async Task OnLevelChanged()
    {
        RefreshVisibleScenes();
        ComputeGridLines();
        // Changing level clears current scene and any selected exits.
        currentScene = null;
        ClearExitSelection();
        await InvokeAsync(StateHasChanged);
    }

    // Injected in razor via @inject; also available here if needed


    private IJSObjectReference? _mapModule;

    public async Task RegisterMapHelpersAsync()
    {
        if (_mapModule != null) return;
        try
        {
            // Import the ES module from the app's wwwroot
            _mapModule = await JS.InvokeAsync<IJSObjectReference>("import", "/js/MapHelpers.js");
        }
        catch
        {
            // swallow - best-effort
        }
    }

    public async Task EnableMapDragAsync(ElementReference el)
    {
        if (_mapModule is not null)
        {
            try { await _mapModule.InvokeVoidAsync("enableDrag", el); } catch { }
        }
    }

    public async Task DisableMapDragAsync(ElementReference el)
    {
        if (_mapModule is not null)
        {
            try { await _mapModule.InvokeVoidAsync("disableDrag", el); } catch { }
        }
    }

    public async ValueTask DisposeMapModuleAsync()
    {
        if (_mapModule is not null)
        {
            try { await _mapModule.DisposeAsync(); } catch { }
            _mapModule = null;
        }
    }

    private void EditCurrentScene()
    {
        if (currentScene == null) return;
        var parameters = new Dictionary<string, object?> { ["Element"] = currentScene };
        DialogService.OpenSide<GameElementEditor>("Edit Scene", parameters, new SideDialogOptions() { Width = "70%" });
    }

    private async Task DeleteCurrentScene()
    {
        if (currentScene == null) return;
        var confirmed = await DialogService.Confirm(
    $"Delete scene '{currentScene.Name}'? This will remove the scene and any exits located in it.",
    "Confirm Delete",
    new ConfirmOptions { OkButtonText = "Delete", CancelButtonText = "Cancel" }
);
        if (confirmed != true) return;

        var pack = CurrentGameService.CurrentPack;
        if (pack is null) return;

        // Remove any exits whose parent is this scene
        pack.Elements.RemoveAll(e => e is Exit && e.Location?.ParentId == currentScene.Id);

        // Remove the scene itself
        pack.Elements.RemoveAll(e => e.Id == currentScene.Id);

        // Clear selections and mark dirty
        ClearExitSelection();
        currentScene = null;
        CurrentGameService.MarkDirty();

        RefreshVisibleScenes();
        ComputeGridLines();
        StateHasChanged();
    }
}

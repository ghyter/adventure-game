@page "/gamepack/map"
@using System.Text.Json
@using AdventureGame.Engine.Models
@inject IJSRuntime JS
@inject AdventureGame.Editor.Services.CurrentGameService CurrentGameService

<RadzenText TextStyle="TextStyle.H3">Map</RadzenText>

<div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
    <button class="rz-button rz-button-primary" @onclick="ZoomIn" title="Zoom in">Zoom In</button>
    <button class="rz-button" @onclick="ZoomOut" title="Zoom out">Zoom Out</button>
    <button class="rz-button" @onclick="ResetZoom" title="Reset zoom">Reset</button>
    <div style="margin-left:8px; color:#333;">Zoom: @Math.Round(Scale * 100) %</div>

    <div style="margin-left:16px; display:flex; gap:8px; align-items:center;">
        <label style="color:#333; font-size:0.9rem;">Level:</label>
        <Radzen.Blazor.RadzenNumeric @bind-Value="Level" TValue="int" Style="width:8ch;"
                                     Change="@(async _ => await OnLevelChanged())" />
    </div>

    <div style="margin-left:auto; color:#666; font-size:0.9rem;">Tip: Hold Ctrl + Mouse Wheel to zoom</div>
</div>

<div class="map-viewport" @ref="_viewportRef"
     style="width:75vw; height:75vh; border:1px solid #ddd; overflow:auto; background:#fafafa; cursor:grab;"
     @onwheel="OnWheel">
    @if (LogicalWidth > 0 && LogicalHeight > 0)
    {
        <div style="width:@(LogicalWidth* Scale)px; height:@(LogicalHeight* Scale)px; position:relative;">
            <div style="position:absolute; top:0; left:0; transform:scale(@Scale); transform-origin:0 0;">
                <svg width="@LogicalWidth" height="@LogicalHeight"
                     viewBox="0 0 @Math.Round(LogicalWidth) @Math.Round(LogicalHeight)"
                     xmlns="http://www.w3.org/2000/svg"
                     @onpointerup="EndSceneDrag">

                    @* GRID PATTERN *@
                    <defs>
                        <pattern id="gridPattern" width="@GridCellWidth" height="@GridCellHeight" patternUnits="userSpaceOnUse">
                            <rect width="@GridCellWidth" height="@GridCellHeight" fill="transparent"
                                  stroke="#666" stroke-width="1" stroke-dasharray="1,6" />
                        </pattern>
                    </defs>
                    <rect x="0" y="0" width="@LogicalWidth" height="@LogicalHeight" fill="url(#gridPattern)" />

                    @* SCENES *@
                    @if (CurrentGameService?.CurrentPack is not null)
                    {
                        @foreach (var s in VisibleScenesOnLevel)
                        {
                            var pos = s.Location.TryGetPosition(out var p) ? p : default;
                            var cols = Math.Max(1, s.ExtentInCells.Columns);
                            var rows = Math.Max(1, s.ExtentInCells.Rows);

                            var leftCol = pos.X - MinX;
                            var topRow = MaxY - (pos.Y + rows - 1);

                            var margin = 15.0; // increased padding so coord labels sit outside scene
                            var rectX = leftCol * GridCellWidth + margin;
                            var rectY = topRow * GridCellHeight + margin;
                            var rectW = Math.Max(4, cols * GridCellWidth - margin * 2);
                            var rectH = Math.Max(8, rows * GridCellHeight - margin * 2);

                            var offset = _sceneOffsets.TryGetValue(s.Id.ToString(), out var off) ? off : (0d, 0d);

                            <g class="scene"
                               transform="translate(@offset.Item1,@offset.Item2)"
                               @onpointerdown="@(e => StartSceneDrag(e, s))"
                               @onpointermove="@(e => DragScene(e))"
                               @onpointerup="EndSceneDrag"
                               style="touch-action:none; cursor:move;">
                                <rect x="@rectX" y="@rectY" width="@rectW" height="@rectH"
                                      fill="#f5e6d3" stroke="#b89f85" rx="6" ry="6" />

                                @* Extent dimensions shown near the top-left inside the scene *@
                                <svg:text x="@(rectX + 8)" y="@(rectY + 14)" font-size="10" fill="#3b2f25" text-anchor="start">@($"{cols}×{rows}")</svg:text>

                                <svg:text x="@(rectX + rectW / 2)" y="@(rectY + rectH - 6)"
                                          font-size="12" fill="#3b2f25" text-anchor="middle">@s.Name</svg:text>

                                
                            </g>
                        }
                    }

                    @* COORD LABELS *@
                    @for (int r = 0; r < RowsTotal; r++)
                    {
                        @for (int c = 0; c < ColsTotal; c++)
                        {
                            var labelX = c * GridCellWidth + 4;
                            var labelY = r * GridCellHeight + 4;
                            var coordX = c + MinX;
                            var coordY = MaxY - r;
                            <svg:text x="@labelX" y="@labelY" font-size="8" fill="#666"
                                      text-anchor="start" dominant-baseline="hanging"
                                      style="pointer-events:none;">@($"({coordX},{coordY})")</svg:text>
                        }
                    }
                </svg>
            </div>
        </div>
    }
    else
    {
        <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#999;">
            Measuring map size...
        </div>
    }
</div>

@code {
    int GridCellWidth = 100;
    int GridCellHeight = 100;
    double LogicalWidth, LogicalHeight;
    int ColsTotal, RowsTotal;
    int MinX, MaxX, MinY, MaxY;
    ElementReference _viewportRef;

    double Scale = 1.0;
    const double ZoomFactor = 1.25;
    const double MinScale = 0.1;
    const double MaxScale = 4.0;

    int Level = 0;
    List<Scene> VisibleScenesOnLevel = new();
    bool _initialized = false;

    // Drag state
    Scene? _draggingScene;
    double _dragStartX, _dragStartY;
    int _startGridX, _startGridY;
    bool _sceneDragging = false;
    double _tempDx, _tempDy;
    Dictionary<string, (double, double)> _sceneOffsets = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await RegisterMapHelpersAsync();
            try { await EnableMapDragAsync(_viewportRef); } catch { }
            CurrentGameService.OnChange += OnPackChanged;
            _initialized = true;
            RefreshVisibleScenes();
            ComputeGridLines();
            StateHasChanged();
        }
    }

    void ComputeGridLines()
    {
        var pack = CurrentGameService.CurrentPack;
        int minX = int.MaxValue, maxX = int.MinValue;
        int minY = int.MaxValue, maxY = int.MinValue;

        if (pack != null)
        {
            foreach (var s in pack.Elements.OfType<Scene>())
            {
                if (s.Location.TryGetPosition(out var p) && p.Z == Level)
                {
                    int x1 = p.X;
                    int x2 = p.X + s.ExtentInCells.Columns - 1;
                    int y1 = p.Y;
                    int y2 = p.Y + s.ExtentInCells.Rows - 1;

                    minX = Math.Min(minX, x1);
                    maxX = Math.Max(maxX, x2);
                    minY = Math.Min(minY, y1);
                    maxY = Math.Max(maxY, y2);
                }
            }
        }

        if (minX == int.MaxValue)
        {
            minX = -1; maxX = 1; minY = -1; maxY = 1;
        }

        minX--; maxX++; minY--; maxY++;

        MinX = minX; MaxX = maxX; MinY = minY; MaxY = maxY;

        ColsTotal = (MaxX - MinX + 1);
        RowsTotal = (MaxY - MinY + 1);
        LogicalWidth = ColsTotal * GridCellWidth;
        LogicalHeight = RowsTotal * GridCellHeight;
    }

    void ZoomIn() => Scale = Math.Clamp(Scale * ZoomFactor, MinScale, MaxScale);
    void ZoomOut() => Scale = Math.Clamp(Scale / ZoomFactor, MinScale, MaxScale);
    void ResetZoom() => Scale = 1.0;

    async Task OnWheel(Microsoft.AspNetCore.Components.Web.WheelEventArgs e)
    {
        if (e.CtrlKey)
        {
            if (e.DeltaY < 0) ZoomIn(); else ZoomOut();
            await InvokeAsync(StateHasChanged);
        }
    }

    void RefreshVisibleScenes()
    {
        VisibleScenesOnLevel.Clear();
        var pack = CurrentGameService.CurrentPack;
        if (pack == null) return;
        foreach (var s in pack.Elements.OfType<Scene>())
            if (s.Location.TryGetPosition(out var p) && p.Z == Level)
                VisibleScenesOnLevel.Add(s);
    }

    void OnPackChanged()
    {
        RefreshVisibleScenes();
        ComputeGridLines();
        InvokeAsync(StateHasChanged);
    }

    void StartSceneDrag(Microsoft.AspNetCore.Components.Web.PointerEventArgs e, Scene scene)
    {
        _draggingScene = scene;
        _sceneDragging = true;
        _dragStartX = e.ClientX;
        _dragStartY = e.ClientY;

        if (scene.Location.TryGetPosition(out var p))
        {
            _startGridX = p.X;
            _startGridY = p.Y;
        }
        _tempDx = _tempDy = 0;
    }

    void DragScene(Microsoft.AspNetCore.Components.Web.PointerEventArgs e)
    {
        if (!_sceneDragging || _draggingScene == null) return;

        _tempDx = (e.ClientX - _dragStartX) / Scale;
        _tempDy = (e.ClientY - _dragStartY) / Scale;

        _sceneOffsets[_draggingScene.Id.ToString()] = (_tempDx, _tempDy);
        InvokeAsync(StateHasChanged);
    }

    void EndSceneDrag()
    {
        if (!_sceneDragging || _draggingScene == null) return;

        int deltaCols = (int)Math.Round(_tempDx / GridCellWidth);
        int deltaRows = (int)Math.Round(_tempDy / GridCellHeight);

        if (_draggingScene.Location.TryGetPosition(out var pos))
        {
            pos = pos with { X = _startGridX + deltaCols, Y = _startGridY - deltaRows };
            _draggingScene.Location = Location.World(pos);
        }

        _sceneOffsets.Remove(_draggingScene.Id.ToString());
        _sceneDragging = false;
        _draggingScene = null;

        CurrentGameService.MarkDirty();
        ComputeGridLines();
        InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        try { await DisableMapDragAsync(_viewportRef); } catch { }
        try { await DisposeMapModuleAsync(); } catch { }
        if (_initialized)
        {
            CurrentGameService.OnChange -= OnPackChanged;
            _initialized = false;
        }
    }

    async Task OnLevelChanged()
    {
        RefreshVisibleScenes();
        ComputeGridLines();
        await InvokeAsync(StateHasChanged);
    }
}

@page "/gamepack/map"
@using System.Text.Json
@inject IJSRuntime JS

@* 
Detailed plan implemented in-file:
- Measure viewport size and compute how many cells fit.
- Add one extra column/row on each side.
- Compute logical canvas size to include extra cells.
- Render spacer sized to the logical canvas * Scale so scrollbars reflect full area.
- Render inner scaled SVG with grid lines and cell coordinate labels.
- Coordinates: center cell is (0,0); x increases to the right, y increases upward.
- Added pointer-drag support so the user can pan the map by dragging the viewport.
*@

<RadzenText TextStyle="TextStyle.H3">Map</RadzenText>

<div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
    <button class="rz-button rz-button-primary" @onclick="ZoomIn" title="Zoom in">Zoom In</button>
    <button class="rz-button" @onclick="ZoomOut" title="Zoom out">Zoom Out</button>
    <button class="rz-button" @onclick="ResetZoom" title="Reset zoom">Reset</button>
    <div style="margin-left:8px; color:#333;">Zoom: @Math.Round(Scale * 100) %</div>
    <div style="margin-left:auto; color:#666; font-size:0.9rem;">Tip: Hold Ctrl + Mouse Wheel to zoom</div>
</div>

@* Viewport: scrollable area; cursor indicates draggable area *@
<div class="map-viewport" @ref="_viewportRef" style="width:75vw; height:75vh; box-sizing:border-box; border:1px solid #ddd; overflow:auto; background:#fafafa; cursor:grab;" @onwheel="OnWheel">
    @if (LogicalWidth > 0 && LogicalHeight > 0)
    {
        @* Spacer defines the scrollable area size (scaled size) *@
        <div style="width:@(LogicalWidth * Scale)px; height:@(LogicalHeight * Scale)px; position:relative;">
            @* Scaled inner: absolute so it sits at top-left and is transformed *@
            <div style="position:absolute; top:0; left:0; transform:scale(@Scale); transform-origin:0 0;">
                <svg width="@LogicalWidth" height="@LogicalHeight" viewBox="0 0 @Math.Round(LogicalWidth) @Math.Round(LogicalHeight)" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="@LogicalWidth" height="@LogicalHeight" fill="transparent" />
                    @* vertical grid lines *@
                    @foreach (var x in VerticalLinePositions)
                    {
                        <line x1="@x" y1="0" x2="@x" y2="@LogicalHeight" stroke="#666" stroke-width="1" stroke-linecap="round" stroke-dasharray="1,6" />
                    }
                    @* horizontal grid lines *@
                    @foreach (var y in HorizontalLinePositions)
                    {
                        <line x1="0" y1="@y" x2="@LogicalWidth" y2="@y" stroke="#666" stroke-width="1" stroke-linecap="round" stroke-dasharray="1,6" />
                    }

                    @* Cell coordinate labels: center of each cell, format "x,y" where center cell is (0,0) and up is positive y *@
                    @for (int r = 0; r < RowsTotal; r++)
                    {
                        @for (int c = 0; c < ColsTotal; c++)
                        {
                            var centerX = c * GridCellWidth + GridCellWidth / 2.0;
                            var centerY = r * GridCellHeight + GridCellHeight / 2.0;
                            var coordX = c - CenterCol;
                            var coordY = CenterRow - r;
                            <svg>
                                <text x="@centerX" y="@centerY" font-size="12" fill="#333" text-anchor="middle" dominant-baseline="middle" style="pointer-events:none;">
                                    @($"{coordX},{coordY}")
                                </text>
                            </svg>
                        }
                    }
                </svg>
            </div>
        </div>
    }
    else
    {
        <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#999;">
            Measuring map size...
        </div>
    }
</div>

@code {
    // Grid cell dimensions (pixels)
    int GridCellWidth = 100;
    int GridCellHeight = 100;

    // Measured viewport size (original measured area)
    double SvgWidth;
    double SvgHeight;

    // Logical canvas size including one extra row/column on each side
    double LogicalWidth;
    double LogicalHeight;

    // Computed counts
    int ColsTotal = 0;
    int RowsTotal = 0;

    // Center indices (cell that maps to coordinate 0,0)
    int CenterCol = 0;
    int CenterRow = 0;

    // Computed grid line positions
    List<double> VerticalLinePositions = new();
    List<double> HorizontalLinePositions = new();

    // Element reference for measuring and viewport interactions
    ElementReference _viewportRef;

    // Scaling (1.0 = 100%)
    double Scale = 1.0;

    // Zoom step factor
    const double ZoomFactor = 1.25;
    const double MinScale = 0.1;
    const double MaxScale = 4.0;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await UpdateSizeAsync();

            // Enable pointer-drag panning on the viewport using lightweight JS handlers.
            try
            {
                await JS.InvokeVoidAsync("mapHelpers.enableDrag", _viewportRef);
            }
            catch
            {
                // ignore if JS not available
            }
        }
    }

    async Task UpdateSizeAsync()
    {
        try
        {
            var rect = await JS.InvokeAsync<JsonElement>("mapHelpers.getSize", _viewportRef);
            if (rect.ValueKind != JsonValueKind.Undefined && rect.ValueKind != JsonValueKind.Null)
            {
                if (rect.TryGetProperty("width", out var w) && rect.TryGetProperty("height", out var h))
                {
                    SvgWidth = w.GetDouble();
                    SvgHeight = h.GetDouble();
                    ComputeGridLines();
                    StateHasChanged();
                }
            }
        }
        catch
        {
            // silent fail - leave default measurements
        }
    }

    void ComputeGridLines()
    {
        VerticalLinePositions.Clear();
        HorizontalLinePositions.Clear();

        if (GridCellWidth <= 0 || GridCellHeight <= 0 || SvgWidth <= 0 || SvgHeight <= 0)
            return;

        // How many cells fit in the measured area
        int colsOriginal = (int)Math.Ceiling(SvgWidth / GridCellWidth);
        int rowsOriginal = (int)Math.Ceiling(SvgHeight / GridCellHeight);

        // Add one extra column/row on each side
        ColsTotal = colsOriginal + 2;
        RowsTotal = rowsOriginal + 2;

        // Logical canvas size that includes the extra cells
        LogicalWidth = ColsTotal * GridCellWidth;
        LogicalHeight = RowsTotal * GridCellHeight;

        // Center cell indices (integer center)
        CenterCol = ColsTotal / 2;
        CenterRow = RowsTotal / 2;

        // Vertical grid lines (boundaries) at 0, GridCellWidth, ..., ColsTotal * GridCellWidth
        for (int i = 0; i <= ColsTotal; i++)
        {
            VerticalLinePositions.Add(i * GridCellWidth);
        }

        // Horizontal grid lines
        for (int i = 0; i <= RowsTotal; i++)
        {
            HorizontalLinePositions.Add(i * GridCellHeight);
        }
    }

    void ZoomIn()
    {
        Scale = Math.Clamp(Scale * ZoomFactor, MinScale, MaxScale);
    }

    void ZoomOut()
    {
        Scale = Math.Clamp(Scale / ZoomFactor, MinScale, MaxScale);
    }

    void ResetZoom()
    {
        Scale = 1.0;
    }

    async Task OnWheel(Microsoft.AspNetCore.Components.Web.WheelEventArgs e)
    {
        // If the user holds Ctrl while scrolling the wheel, treat it as zoom
        if (e.CtrlKey)
        {
            // DeltaY < 0 => wheel up => zoom in
            if (e.DeltaY < 0)
                ZoomIn();
            else
                ZoomOut();

            // Update UI
            await InvokeAsync(StateHasChanged);
        }
    }

    // Clean up drag handlers when the component is disposed
    public async ValueTask DisposeAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("mapHelpers.disableDrag", _viewportRef);
        }
        catch
        {
            // ignore
        }
    }
}

@* Minimal JS helpers for measuring element size and enabling pointer-drag panning. *@
<script>
    window.mapHelpers = {
        getSize: function (el) {
            if (!el) return null;
            var r = el.getBoundingClientRect();
            return { width: r.width, height: r.height };
        },

        enableDrag: function (el) {
            if (!el) return;
            // do nothing if already initialized
            if (el._dragHandlers) return;

            let dragging = false;
            let lastX = 0, lastY = 0;

            function start(e) {
                // Only primary button
                if (e.button !== 0) return;
                dragging = true;
                try { el.setPointerCapture(e.pointerId); } catch (ex) { }
                lastX = e.clientX;
                lastY = e.clientY;
                el.style.cursor = 'grabbing';
                // prevent default to avoid text selection
                e.preventDefault();
            }

            function move(e) {
                if (!dragging) return;
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                // Invert delta because dragging moves content opposite to pointer movement
                el.scrollLeft -= dx;
                el.scrollTop -= dy;
                lastX = e.clientX;
                lastY = e.clientY;
            }

            function end(e) {
                if (!dragging) return;
                dragging = false;
                try { el.releasePointerCapture(e.pointerId); } catch (ex) { }
                el.style.cursor = 'grab';
            }

            el.addEventListener('pointerdown', start, { passive: false });
            el.addEventListener('pointermove', move);
            el.addEventListener('pointerup', end);
            el.addEventListener('pointercancel', end);

            el._dragHandlers = { start, move, end };
        },

        disableDrag: function (el) {
            if (!el || !el._dragHandlers) return;
            const { start, move, end } = el._dragHandlers;
            el.removeEventListener('pointerdown', start);
            el.removeEventListener('pointermove', move);
            el.removeEventListener('pointerup', end);
            el.removeEventListener('pointercancel', end);
            delete el._dragHandlers;
            el.style.cursor = '';
        }
    };
</script>

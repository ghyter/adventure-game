@page "/games"
@using AdventureGame.Engine.Models
@using Radzen
@using Radzen.Blazor
@using Microsoft.AspNetCore.Components.Forms
@using NUlid
@inject DialogService DialogService
@inject NotificationService NotificationService
@inject IGamePackRepository Repo
@inject IJSRuntime JSRuntime
@inject AdventureGame.Editor.Services.CurrentGameService CurrentGameService

<RadzenText TextStyle="TextStyle.H3">Games</RadzenText>

<RadzenRow Class="games-header">
    <RadzenColumn Size="6">
        <RadzenStack Orientation="Orientation.Horizontal" Gap="8" AlignItems="AlignItems.Center">
            <RadzenButton Icon="add_circle" ButtonStyle="ButtonStyle.Primary" Click="@NewGamePack">New GamePack</RadzenButton>
            <InputFile OnChange="ImportFile" accept=".json" />
        </RadzenStack>
    </RadzenColumn>

    <RadzenColumn Size="6" Class="games-header-right">
        <RadzenStack Orientation="Orientation.Horizontal" Gap="12" AlignItems="AlignItems.Center" JustifyContent="JustifyContent.End">
            <RadzenText Style="opacity:0.8">@($"{gamePacks.Count} game pack(s)")</RadzenText>

            <RadzenDropDown Style="width:180px"
                            Data="@sortOptions"
                            TextProperty="Text"
                            ValueProperty="Value"
                            @bind-Value="selectedSort"
                            Change="OnSortChanged" />
        </RadzenStack>
    </RadzenColumn>
</RadzenRow>

<div class="games-grid">
    @foreach (var gp in OrderedPacks())
    {
        var isCurrent = CurrentGameService.CurrentPack is not null && gp.Id == CurrentGameService.CurrentPack.Id;

        <RadzenCard Class="game-card">
            <RadzenRow>
                <RadzenColumn Size="9">
                    <RadzenStack Orientation="Orientation.Vertical" Gap="8">
                        <RadzenText Style="font-weight:600">@gp.Name</RadzenText>
                        <RadzenStack Orientation="Orientation.Horizontal" Gap="8" AlignItems="AlignItems.Center">
                            <RadzenBadge Text=@gp.Version />
                            @if (isCurrent)
                            {
                                <RadzenBadge Text="Current" />
                            }
                        </RadzenStack>

                        <RadzenText Style="color:var(--rz-secondary-text); font-size:0.85rem;">
                            <div>Created: @gp.CreatedAt.ToLocalTime().ToString("g")</div>
                            <div>Modified: @gp.ModifiedAt.ToLocalTime().ToString("g")</div>
                        </RadzenText>
                    </RadzenStack>
                </RadzenColumn>

                <RadzenColumn Size="3">
                    <RadzenStack Orientation="Orientation.Vertical" Gap="6" AlignItems="AlignItems.End">
                        <RadzenButton Icon="edit" Size="ButtonSize.Small" ButtonStyle="ButtonStyle.Light" Click="@(args => EditGamePack(gp))" />
                        <RadzenButton Icon="delete" Size="ButtonSize.Small" ButtonStyle="ButtonStyle.Danger" Click="@(args => ConfirmDelete(gp))" />
                    </RadzenStack>
                </RadzenColumn>
            </RadzenRow>

            <RadzenText Class="game-description"> 
                @if (string.IsNullOrWhiteSpace(gp.Description))
                {
                    <em>No description</em>
                }
                else
                {
                    @gp.Description
                }
            </RadzenText>

            <RadzenRow>
                <RadzenColumn>
                    <RadzenStack Orientation="Orientation.Horizontal" Gap="8">
                        @if (isCurrent)
                        {
                            <RadzenButton Text="Deselect" Size="ButtonSize.Small" ButtonStyle="ButtonStyle.Light" Click="@(async args => { CurrentGameService.ClearCurrent(); await InvokeAsync(StateHasChanged); })" />
                        }
                        else
                        {
                            <RadzenButton Text="Select" Size="ButtonSize.Small" ButtonStyle="ButtonStyle.Primary" Click="@(async args => { CurrentGameService.SetCurrent(gp); await InvokeAsync(StateHasChanged); })" />
                        }

                        <RadzenButton Text="Clone" Icon="content_copy" Size="ButtonSize.Small" ButtonStyle="ButtonStyle.Light" Click="@(async args => await CloneGamePack(gp))" />
                    </RadzenStack>
                </RadzenColumn>

                <RadzenColumn Style="display:flex; justify-content:flex-end;">
                    <RadzenButton Icon="file_download" Text="Export" Size="ButtonSize.Small" ButtonStyle="ButtonStyle.Secondary" Click="@(async args => await ExportGamePack(gp))" />
                </RadzenColumn>
            </RadzenRow>
        </RadzenCard>
    }
</div>

<style>
    .games-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
        gap: 12px;
        align-items: start;
    }

    .game-card {
        padding: 12px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        height: 240px;
    }

    .games-header {
        margin: 12px 0;
        align-items: center;
    }

    .games-header-right {
        display: flex;
        justify-content: flex-end;
        align-items: center;
    }

    .game-description {
        margin-top: 12px;
        color: var(--rz-secondary-text);
        font-size: 0.95rem;
        overflow: hidden;
        max-height: 96px;
    }
</style>

@code {
    private readonly List<GamePack> gamePacks = new();

    private record SortItem(string Value, string Text);
    private readonly List<SortItem> sortOptions = new()
    {
        new SortItem("name", "Sort: Name (A→Z)"),
        new SortItem("recent", "Sort: Recent (Modified)"),
        new SortItem("created", "Sort: Created")
    };

    private string selectedSort = "recent";

    protected override async Task OnInitializedAsync()
    {
        await Repo.InitializeAsync();
        var list = await Repo.GetAllAsync();
        gamePacks.Clear();
        gamePacks.AddRange(list);
    }

    private Task OnSortChanged(object value)
    {
        selectedSort = value?.ToString() ?? "recent";
        return InvokeAsync(StateHasChanged);
    }

    private IEnumerable<GamePack> OrderedPacks()
        => selectedSort switch
        {
            "name" => gamePacks.OrderBy(g => g.Name, StringComparer.OrdinalIgnoreCase),
            "created" => gamePacks.OrderByDescending(g => g.CreatedAt),
            _ => gamePacks.OrderByDescending(g => g.ModifiedAt) // recent by default
        };

    private async void NewGamePack()
    {
        var model = new GamePack();
        await OpenEditorAsync(model, true);
    }

    private async void EditGamePack(GamePack gp)
    {
        var model = gp.Clone();
        await OpenEditorAsync(model, false);
    }

    private async Task OpenEditorAsync(GamePack model, bool isNew)
    {
        var parameters = new Dictionary<string, object?> { ["Model"] = model, ["IsNew"] = isNew };
        var result = await DialogService.OpenSideAsync<AdventureGame.Editor.Components.GamePackSideEditor>(
            title: isNew ? "New GamePack" : "Edit GamePack",
            parameters: parameters,
            options: new SideDialogOptions() { Width = "420px" }
        );

        if (result is GamePack saved)
        {
            if (gamePacks.Any(g => g.Id == saved.Id))
            {
                await Repo.UpdateAsync(saved);
                var idx = gamePacks.FindIndex(g => g.Id == saved.Id);
                gamePacks[idx] = saved.Clone();
            }
            else
            {
                await Repo.AddAsync(saved);
                gamePacks.Insert(0, saved.Clone());
            }

            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Success, Summary = isNew ? "Created" : "Saved", Detail = $"GamePack '{saved.Name}' persisted.", Duration = 3000 });
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ConfirmDelete(GamePack gp)
    {
        var confirmed = await DialogService.Confirm($"Delete '{gp.Name}'? This action cannot be undone.", "Confirm Delete",
            new ConfirmOptions() { OkButtonText = "Delete", CancelButtonText = "Cancel" });

        if (confirmed == true)
        {
            await DeleteGamePack(gp);
            StateHasChanged();
        }
    }

    private async Task DeleteGamePack(GamePack gp)
    {
        await Repo.DeleteAsync(gp.Id.ToString());
        var removed = gamePacks.RemoveAll(g => g.Id == gp.Id);
        if (removed > 0)
        {
            // If deleted pack was current, clear selection.
            if (CurrentGameService.CurrentPack is not null && CurrentGameService.CurrentPack.Id == gp.Id)
            {
                CurrentGameService.ClearCurrent();
            }

            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Success, Summary = "Deleted", Detail = $"GamePack '{gp.Name}' deleted.", Duration = 3000 });
        }
    }

    private async Task ExportGamePack(GamePack gp)
    {
        var json = gp.ToJson();
        var bytes = System.Text.Encoding.UTF8.GetBytes(json);
        var base64 = Convert.ToBase64String(bytes);

        var safeName = SanitizeFileName(string.IsNullOrWhiteSpace(gp.Name) ? "gamepack" : gp.Name);
        var fileName = $"{safeName}-{gp.Id}.json";

        await JSRuntime.InvokeVoidAsync("blazorDownloadFile", fileName, "application/json;charset=utf-8", base64);

        NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Info, Summary = "Exported", Detail = $"GamePack '{gp.Name}' downloaded ({json.Length} chars).", Duration = 3000 });
    }

    // Clone an existing GamePack as a new pack (new Ulid + timestamps), persist and insert into the list.
    private async Task CloneGamePack(GamePack gp)
    {
        if (gp == null) return;

        // Deep clone then assign new identity/timestamps
        var clone = gp.Clone();
        clone.Id = Ulid.NewUlid();
        clone.CreatedAt = DateTime.UtcNow;
        clone.ModifiedAt = DateTime.UtcNow;

        // Append "(Clone)" to the cloned pack name if not already present
        clone.Name = AppendCloneSuffix(clone.Name);

        await Repo.AddAsync(clone);
        gamePacks.Insert(0, clone.Clone()); // insert a fresh copy for UI list

        NotificationService.Notify(new NotificationMessage
        {
            Severity = NotificationSeverity.Success,
            Summary = "Cloned",
            Detail = $"GamePack '{gp.Name}' cloned.",
            Duration = 3000
        });

        await InvokeAsync(StateHasChanged);
    }

    private static string AppendCloneSuffix(string? name)
    {
        var n = (name ?? "").Trim();
        if (n.EndsWith(" (Clone)", StringComparison.OrdinalIgnoreCase))
            return n;
        return string.IsNullOrEmpty(n) ? "(Clone)" : $"{n} (Clone)";
    }

    // Import handler: reads uploaded JSON, deserializes and validates, then saves.
    private async Task ImportFile(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file == null)
        {
            return;
        }

        try
        {
            // Limit to 5 MB
            const long maxBytes = 5 * 1024 * 1024;
            using var stream = file.OpenReadStream(maxBytes);
            using var reader = new System.IO.StreamReader(stream);
            var json = await reader.ReadToEndAsync();

            GamePack? pack;
            try
            {
                pack = GamePack.FromJson(json);
            }
            catch (Exception ex)
            {
                NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Import failed", Detail = $"Invalid JSON: {ex.Message}", Duration = 5000 });
                return;
            }

            if (pack == null || string.IsNullOrWhiteSpace(pack.Name))
            {
                NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Warning, Summary = "Invalid GamePack", Detail = "Uploaded file is not a valid GamePack (missing name).", Duration = 5000 });
                return;
            }

            // If pack already exists, prompt for overwrite or clone
            var exists = gamePacks.Any(g => g.Id == pack.Id);
            if (exists)
            {
                // First: ask overwrite
                var overwrite = await DialogService.Confirm($"A GamePack with the same Id already exists: '{pack.Name}'. Overwrite it?", "Overwrite GamePack",
                    new ConfirmOptions() { OkButtonText = "Overwrite", CancelButtonText = "Cancel" });

                if (overwrite == true)
                {
                    // Overwrite existing
                    await Repo.UpdateAsync(pack);
                    var idx = gamePacks.FindIndex(g => g.Id == pack.Id);
                    if (idx >= 0) gamePacks[idx] = pack.Clone();
                    NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Success, Summary = "Imported", Detail = $"GamePack '{pack.Name}' overwritten.", Duration = 3000 });
                    await InvokeAsync(StateHasChanged);
                    return;
                }

                // If user cancelled overwrite, offer cloning
                var cloneConfirm = await DialogService.Confirm($"Create a cloned copy of '{pack.Name}' instead? The clone will get a new Id.", "Clone GamePack",
                    new ConfirmOptions() { OkButtonText = "Clone", CancelButtonText = "Cancel" });

                if (cloneConfirm == true)
                {
                    // Make a cloned new pack with a fresh Ulid
                    pack.Id = Ulid.NewUlid();
                    pack.CreatedAt = DateTime.UtcNow;
                    pack.ModifiedAt = DateTime.UtcNow;

                    await Repo.AddAsync(pack);
                    gamePacks.Insert(0, pack.Clone());
                    NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Success, Summary = "Imported", Detail = $"GamePack '{pack.Name}' cloned and added.", Duration = 3000 });
                    await InvokeAsync(StateHasChanged);
                    return;
                }

                // User chose not to overwrite or clone
                NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Info, Summary = "Import cancelled", Detail = "Import was cancelled.", Duration = 3000 });
                return;
            }

            // Persist: update if exists in repo list, otherwise add (normal path)
            if (gamePacks.Any(g => g.Id == pack.Id))
            {
                await Repo.UpdateAsync(pack);
                var idx = gamePacks.FindIndex(g => g.Id == pack.Id);
                gamePacks[idx] = pack.Clone();
                NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Success, Summary = "Imported", Detail = $"GamePack '{pack.Name}' updated.", Duration = 3000 });
            }
            else
            {
                await Repo.AddAsync(pack);
                gamePacks.Insert(0, pack.Clone());
                NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Success, Summary = "Imported", Detail = $"GamePack '{pack.Name}' added.", Duration = 3000 });
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (System.IO.IOException)
        {
            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Import failed", Detail = "File too large or could not be read.", Duration = 5000 });
        }
        catch (Exception ex)
        {
            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Import failed", Detail = ex.Message, Duration = 5000 });
        }
    }

    private static string SanitizeFileName(string name)
    {
        var invalid = System.IO.Path.GetInvalidFileNameChars();
        var sb = new System.Text.StringBuilder(name.Length);
        foreach (var c in name)
        {
            if (Array.IndexOf(invalid, c) < 0)
                sb.Append(c);
            else
                sb.Append('_');
        }
        return sb.ToString();
    }
}

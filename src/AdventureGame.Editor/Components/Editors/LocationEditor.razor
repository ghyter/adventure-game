@implements IDisposable
@inject CurrentGameService CurrentGameService

<RadzenFieldset Text="Location" Style="width:100%">
    <RadzenStack Orientation="Orientation.Vertical" Gap="8">

        @if (OwnerElement is not Level)
        {
            <RadzenFormField Text="@ParentLabel">
                <RadzenDropDown @key="@_parentOptions.Count"
                                Data="@_parentOptions"
                                TextProperty="Name"
                                ValueProperty="Id"
                                @bind-Value="ParentId"
                                TValue="ElementId?"
                                Style="width:100%"
                                Placeholder="@ParentPlaceholder"
                                AllowClear="true"
                                Change="@(async _ => await OnParentChanged())" />
            </RadzenFormField>
        }

        @if (OwnerElement is Scene)
        {
            <RadzenStack Orientation="Orientation.Horizontal" Gap="8" Style="align-items:center;">
                <RadzenFormField Text="Col">
                    <RadzenNumeric Value="Position.X"
                                   TValue="int"
                                   Style="width:12ch"
                                   Change="@(async x => await UpdatePosition(x, Position.Y))" />
                </RadzenFormField>
                <RadzenFormField Text="Row">
                    <RadzenNumeric Value="Position.Y"
                                   TValue="int"
                                   Style="width:12ch"
                                   Change="@(async y => await UpdatePosition(Position.X, y))" />
                </RadzenFormField>
            </RadzenStack>
        }
    </RadzenStack>
</RadzenFieldset>

@code {
    [Parameter] public GameElement? OwnerElement { get; set; }

    private GridPosition Position { get; set; } = GridPosition.Origin;
    private ElementId? ParentId { get; set; }
    private readonly List<GameElement> _parentOptions = new();
    private bool _suppressParameterSync;

    private GamePack? Pack => CurrentGameService.CurrentPack;

    protected override void OnInitialized()
    {
        CurrentGameService.OnChange += OnPackChanged;
        base.OnInitialized();
    }

    public void Dispose() => CurrentGameService.OnChange -= OnPackChanged;

    private void OnPackChanged()
    {
        RebuildParentOptions();
        // For a Scene, auto-select first level if none chosen
        if (OwnerElement is Scene && ParentId is null)
        {
            var firstLevel = _parentOptions.OfType<Level>().FirstOrDefault();
            if (firstLevel is not null)
                ParentId = firstLevel.Id;
        }
        InvokeAsync(StateHasChanged);
    }

    protected override void OnParametersSet()
    {
        if (_suppressParameterSync) return;

        if (OwnerElement is Scene s)
        {
            Position = s.Position ?? GridPosition.Origin;
            ParentId = s.ParentId;
        }
        else if (OwnerElement is not null)
        {
            ParentId = OwnerElement.ParentId;
        }

        RebuildParentOptions();

        if (OwnerElement is Scene && ParentId is null)
        {
            var firstLevel = _parentOptions.OfType<Level>().FirstOrDefault();
            if (firstLevel is not null)
                ParentId = firstLevel.Id;
        }
    }

    private void RebuildParentOptions()
    {
        _parentOptions.Clear();
        var all = Pack?.Elements ?? Enumerable.Empty<GameElement>();

        IEnumerable<GameElement> options = OwnerElement switch
        {
            Scene => all.OfType<Level>(), // Scene parent is Level
            Exit => all.OfType<Scene>(),  // Exits live in Scenes
            Npc => all.Where(e => e is Scene or Player),
            Player => all.Where(e => e is Scene or Player),
            Item => all.Where(e =>
                (e is Scene or Item or Npc or Player) &&
                e is not Exit &&
                OwnerElement is not null &&
                e.Id != OwnerElement.Id &&
                !CreatesCircularReference(OwnerElement, e)),
            Level => Enumerable.Empty<GameElement>(),
            _ => Enumerable.Empty<GameElement>()
        };

        _parentOptions.AddRange(options);
    }

    private string ParentLabel =>
        OwnerElement switch
        {
            Scene => "Level",
            Exit => "Scene",
            Npc => "Scene / Player",
            Player => "Scene / Player",
            Item => "Container / Scene / Actor",
            _ => "Parent"
        };

    private string ParentPlaceholder =>
        OwnerElement switch
        {
            Scene => "Select level (optional)",
            Item => "Select container or clear for Off Map",
            Npc => "Select scene/player or clear",
            Player => "Select scene/player or clear",
            Exit => "Select scene",
            _ => "Select parent or clear"
        };

    private bool CreatesCircularReference(GameElement owner, GameElement potentialParent)
    {
        if (Pack is null || potentialParent is not Item)
            return false;

        var visited = new HashSet<ElementId>();
        var current = potentialParent;

        while (current is Item it)
        {
            if (!visited.Add(it.Id))
                return true;

            if (it.ParentId is not ElementId pid)
                return false;

            if (pid == owner.Id)
                return true;

            var parent = Pack.Elements.FirstOrDefault(e => e.Id == pid);
            if (parent is null)
                return false;

            current = parent;
        }

        return false;
    }

    private async Task UpdatePosition(object? x, object? y)
    {
        Position = new GridPosition(
            x is int xi ? xi : Position.X,
            y is int yi ? yi : Position.Y
        );
        await ApplyWorldLocation();
    }

    private async Task OnParentChanged()
    {
        if (OwnerElement is Scene)
        {
            await ApplyWorldLocation();
        }
        else
        {
            await ApplyEmbeddedOrOffMap();
        }
    }

    private async Task ApplyWorldLocation()
    {
        _suppressParameterSync = true;
        if (OwnerElement is Scene s)
        {
            s.Position = Position;
            s.ParentId = ParentId;
        }
        await Commit();
        _suppressParameterSync = false;
    }

    private async Task ApplyEmbeddedOrOffMap()
    {
        _suppressParameterSync = true;
        if (OwnerElement is not null)
        {
            OwnerElement.ParentId = ParentId;
        }
        await Commit();
        _suppressParameterSync = false;
    }

    private async Task Commit()
    {
        CurrentGameService.MarkDirty();
        await InvokeAsync(StateHasChanged);
    }
}

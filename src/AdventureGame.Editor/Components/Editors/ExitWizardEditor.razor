@using AdventureGame.Editor.Services
@using AdventureGame.Engine.Extensions
@using AdventureGame.Engine.Models
@using AdventureGame.Engine.Components
@inject CurrentGameService CurrentGameService
<h3>Exit Wizard</h3>

<Compass ActiveExits="@ActiveExits" SecondaryExits="@AdjacentRooms" OnExitClicked="ExitClicked"/>
<RadzenText Text="@LastClickedDirection"/>

@code{
    [Parameter]
    public GameElement? Element { get; set; }

    private string LastClickedDirection = string.Empty;

    // now strongly-typed sets of Direction
    private HashSet<Direction> ActiveExits { get; set; } = new();
    private HashSet<Direction> AdjacentRooms { get; set; } = new();

    private void ExitClicked(Direction dir)
    {
        // use abbreviation for concise UI consistency
        LastClickedDirection = dir.ToAbbreviation();
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        ActiveExits.Clear();
        AdjacentRooms.Clear();

        if (Element == null)
            return;

        var pack = CurrentGameService.CurrentPack;
        if (pack == null)
            return;

        // Determine the scene that owns this exit (parent) or, if the element is a Scene itself, use it.
        Scene? ownerScene = null;

        if (Element is Scene sElem)
        {
            ownerScene = sElem;
        }
        else
        {
            if (Element.Location?.TryGetParent(out var pid) == true)
            {
                ownerScene = pack.Elements.OfType<Scene>().FirstOrDefault(sc => sc.Id == pid);
            }
        }

        if (ownerScene == null)
            return;

        // Get the world position of the owner scene
        if (!ownerScene.Location.TryGetPosition(out var scenePos))
            return;

        // Find existing directional exits in the same scene
        var exitsInScene = pack.Elements.OfType<Exit>().Where(ex => ex.Location?.TryGetParent(out var pid) == true && pid == ownerScene.Id);
        foreach (var ex in exitsInScene)
        {
            if (ex.Direction is Direction dir)
            {
                ActiveExits.Add(dir);
            }
        }

            // Use GamePackMapExtensions.GetNeighbors which respects scene extents (OccupiedCells)
        foreach (var (dir, pos, neighborScene) in pack.GetNeighbors(scenePos))
        {
            if (ActiveExits.Contains(dir))
                continue; // already has an exit

            if (neighborScene is null)
                continue; // no scene at that neighbour cell

            if (neighborScene.Id == ownerScene.Id)
                continue; // skip the owner itself

            AdjacentRooms.Add(dir);
        }

        // Ensure UI updates
        StateHasChanged();
    }
}